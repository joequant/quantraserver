// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCHEDULE_QUANTRA_H_
#define FLATBUFFERS_GENERATED_SCHEDULE_QUANTRA_H_

#include "flatbuffers/flatbuffers.h"

#include "enums_generated.h"

namespace quantra {

struct Schedule;
struct ScheduleBuilder;
struct ScheduleT;

struct ScheduleT : public flatbuffers::NativeTable {
  typedef Schedule TableType;
  quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina;
  std::string effective_date{};
  std::string termination_date{};
  quantra::enums::Frequency frequency = quantra::enums::Frequency_Annual;
  quantra::enums::BusinessDayConvention convention = quantra::enums::BusinessDayConvention_Following;
  quantra::enums::BusinessDayConvention termination_date_convention = quantra::enums::BusinessDayConvention_Following;
  quantra::enums::DateGenerationRule date_generation_rule = quantra::enums::DateGenerationRule_Backward;
  bool end_of_month = false;
};

struct Schedule FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScheduleT NativeTableType;
  typedef ScheduleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CALENDAR = 4,
    VT_EFFECTIVE_DATE = 6,
    VT_TERMINATION_DATE = 8,
    VT_FREQUENCY = 10,
    VT_CONVENTION = 12,
    VT_TERMINATION_DATE_CONVENTION = 14,
    VT_DATE_GENERATION_RULE = 16,
    VT_END_OF_MONTH = 18
  };
  quantra::enums::Calendar calendar() const {
    return static_cast<quantra::enums::Calendar>(GetField<int8_t>(VT_CALENDAR, 0));
  }
  const flatbuffers::String *effective_date() const {
    return GetPointer<const flatbuffers::String *>(VT_EFFECTIVE_DATE);
  }
  const flatbuffers::String *termination_date() const {
    return GetPointer<const flatbuffers::String *>(VT_TERMINATION_DATE);
  }
  quantra::enums::Frequency frequency() const {
    return static_cast<quantra::enums::Frequency>(GetField<int8_t>(VT_FREQUENCY, 0));
  }
  quantra::enums::BusinessDayConvention convention() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_CONVENTION, 0));
  }
  quantra::enums::BusinessDayConvention termination_date_convention() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_TERMINATION_DATE_CONVENTION, 0));
  }
  quantra::enums::DateGenerationRule date_generation_rule() const {
    return static_cast<quantra::enums::DateGenerationRule>(GetField<int8_t>(VT_DATE_GENERATION_RULE, 0));
  }
  bool end_of_month() const {
    return GetField<uint8_t>(VT_END_OF_MONTH, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_CALENDAR) &&
           VerifyOffset(verifier, VT_EFFECTIVE_DATE) &&
           verifier.VerifyString(effective_date()) &&
           VerifyOffset(verifier, VT_TERMINATION_DATE) &&
           verifier.VerifyString(termination_date()) &&
           VerifyField<int8_t>(verifier, VT_FREQUENCY) &&
           VerifyField<int8_t>(verifier, VT_CONVENTION) &&
           VerifyField<int8_t>(verifier, VT_TERMINATION_DATE_CONVENTION) &&
           VerifyField<int8_t>(verifier, VT_DATE_GENERATION_RULE) &&
           VerifyField<uint8_t>(verifier, VT_END_OF_MONTH) &&
           verifier.EndTable();
  }
  ScheduleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ScheduleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Schedule> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScheduleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ScheduleBuilder {
  typedef Schedule Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_calendar(quantra::enums::Calendar calendar) {
    fbb_.AddElement<int8_t>(Schedule::VT_CALENDAR, static_cast<int8_t>(calendar), 0);
  }
  void add_effective_date(flatbuffers::Offset<flatbuffers::String> effective_date) {
    fbb_.AddOffset(Schedule::VT_EFFECTIVE_DATE, effective_date);
  }
  void add_termination_date(flatbuffers::Offset<flatbuffers::String> termination_date) {
    fbb_.AddOffset(Schedule::VT_TERMINATION_DATE, termination_date);
  }
  void add_frequency(quantra::enums::Frequency frequency) {
    fbb_.AddElement<int8_t>(Schedule::VT_FREQUENCY, static_cast<int8_t>(frequency), 0);
  }
  void add_convention(quantra::enums::BusinessDayConvention convention) {
    fbb_.AddElement<int8_t>(Schedule::VT_CONVENTION, static_cast<int8_t>(convention), 0);
  }
  void add_termination_date_convention(quantra::enums::BusinessDayConvention termination_date_convention) {
    fbb_.AddElement<int8_t>(Schedule::VT_TERMINATION_DATE_CONVENTION, static_cast<int8_t>(termination_date_convention), 0);
  }
  void add_date_generation_rule(quantra::enums::DateGenerationRule date_generation_rule) {
    fbb_.AddElement<int8_t>(Schedule::VT_DATE_GENERATION_RULE, static_cast<int8_t>(date_generation_rule), 0);
  }
  void add_end_of_month(bool end_of_month) {
    fbb_.AddElement<uint8_t>(Schedule::VT_END_OF_MONTH, static_cast<uint8_t>(end_of_month), 0);
  }
  explicit ScheduleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Schedule> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Schedule>(end);
    return o;
  }
};

inline flatbuffers::Offset<Schedule> CreateSchedule(
    flatbuffers::FlatBufferBuilder &_fbb,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina,
    flatbuffers::Offset<flatbuffers::String> effective_date = 0,
    flatbuffers::Offset<flatbuffers::String> termination_date = 0,
    quantra::enums::Frequency frequency = quantra::enums::Frequency_Annual,
    quantra::enums::BusinessDayConvention convention = quantra::enums::BusinessDayConvention_Following,
    quantra::enums::BusinessDayConvention termination_date_convention = quantra::enums::BusinessDayConvention_Following,
    quantra::enums::DateGenerationRule date_generation_rule = quantra::enums::DateGenerationRule_Backward,
    bool end_of_month = false) {
  ScheduleBuilder builder_(_fbb);
  builder_.add_termination_date(termination_date);
  builder_.add_effective_date(effective_date);
  builder_.add_end_of_month(end_of_month);
  builder_.add_date_generation_rule(date_generation_rule);
  builder_.add_termination_date_convention(termination_date_convention);
  builder_.add_convention(convention);
  builder_.add_frequency(frequency);
  builder_.add_calendar(calendar);
  return builder_.Finish();
}

inline flatbuffers::Offset<Schedule> CreateScheduleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina,
    const char *effective_date = nullptr,
    const char *termination_date = nullptr,
    quantra::enums::Frequency frequency = quantra::enums::Frequency_Annual,
    quantra::enums::BusinessDayConvention convention = quantra::enums::BusinessDayConvention_Following,
    quantra::enums::BusinessDayConvention termination_date_convention = quantra::enums::BusinessDayConvention_Following,
    quantra::enums::DateGenerationRule date_generation_rule = quantra::enums::DateGenerationRule_Backward,
    bool end_of_month = false) {
  auto effective_date__ = effective_date ? _fbb.CreateString(effective_date) : 0;
  auto termination_date__ = termination_date ? _fbb.CreateString(termination_date) : 0;
  return quantra::CreateSchedule(
      _fbb,
      calendar,
      effective_date__,
      termination_date__,
      frequency,
      convention,
      termination_date_convention,
      date_generation_rule,
      end_of_month);
}

flatbuffers::Offset<Schedule> CreateSchedule(flatbuffers::FlatBufferBuilder &_fbb, const ScheduleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline ScheduleT *Schedule::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ScheduleT>(new ScheduleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Schedule::UnPackTo(ScheduleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = calendar(); _o->calendar = _e; }
  { auto _e = effective_date(); if (_e) _o->effective_date = _e->str(); }
  { auto _e = termination_date(); if (_e) _o->termination_date = _e->str(); }
  { auto _e = frequency(); _o->frequency = _e; }
  { auto _e = convention(); _o->convention = _e; }
  { auto _e = termination_date_convention(); _o->termination_date_convention = _e; }
  { auto _e = date_generation_rule(); _o->date_generation_rule = _e; }
  { auto _e = end_of_month(); _o->end_of_month = _e; }
}

inline flatbuffers::Offset<Schedule> Schedule::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScheduleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSchedule(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Schedule> CreateSchedule(flatbuffers::FlatBufferBuilder &_fbb, const ScheduleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ScheduleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _calendar = _o->calendar;
  auto _effective_date = _o->effective_date.empty() ? 0 : _fbb.CreateString(_o->effective_date);
  auto _termination_date = _o->termination_date.empty() ? 0 : _fbb.CreateString(_o->termination_date);
  auto _frequency = _o->frequency;
  auto _convention = _o->convention;
  auto _termination_date_convention = _o->termination_date_convention;
  auto _date_generation_rule = _o->date_generation_rule;
  auto _end_of_month = _o->end_of_month;
  return quantra::CreateSchedule(
      _fbb,
      _calendar,
      _effective_date,
      _termination_date,
      _frequency,
      _convention,
      _termination_date_convention,
      _date_generation_rule,
      _end_of_month);
}

}  // namespace quantra

#endif  // FLATBUFFERS_GENERATED_SCHEDULE_QUANTRA_H_
