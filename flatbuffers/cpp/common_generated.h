// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_COMMON_QUANTRA_H_
#define FLATBUFFERS_GENERATED_COMMON_QUANTRA_H_

#include "flatbuffers/flatbuffers.h"

#include "enums_generated.h"
#include "coupon_pricer_generated.h"
#include "schedule_generated.h"
#include "term_structure_generated.h"

namespace quantra {

struct Yield;
struct YieldBuilder;
struct YieldT;

struct Pricing;
struct PricingBuilder;
struct PricingT;

struct Error;
struct ErrorBuilder;
struct ErrorT;

struct FlowInterest;
struct FlowInterestBuilder;
struct FlowInterestT;

struct FlowInterestFloat;
struct FlowInterestFloatBuilder;
struct FlowInterestFloatT;

struct FlowPastInterestFloat;
struct FlowPastInterestFloatBuilder;
struct FlowPastInterestFloatT;

struct FlowPastInterest;
struct FlowPastInterestBuilder;
struct FlowPastInterestT;

struct FlowNotional;
struct FlowNotionalBuilder;
struct FlowNotionalT;

struct FlowsWrapper;
struct FlowsWrapperBuilder;
struct FlowsWrapperT;

enum Flow : uint8_t {
  Flow_NONE = 0,
  Flow_FlowInterest = 1,
  Flow_FlowPastInterest = 2,
  Flow_FlowNotional = 3,
  Flow_MIN = Flow_NONE,
  Flow_MAX = Flow_FlowNotional
};

inline const Flow (&EnumValuesFlow())[4] {
  static const Flow values[] = {
    Flow_NONE,
    Flow_FlowInterest,
    Flow_FlowPastInterest,
    Flow_FlowNotional
  };
  return values;
}

inline const char * const *EnumNamesFlow() {
  static const char * const names[5] = {
    "NONE",
    "FlowInterest",
    "FlowPastInterest",
    "FlowNotional",
    nullptr
  };
  return names;
}

inline const char *EnumNameFlow(Flow e) {
  if (flatbuffers::IsOutRange(e, Flow_NONE, Flow_FlowNotional)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFlow()[index];
}

template<typename T> struct FlowTraits {
  static const Flow enum_value = Flow_NONE;
};

template<> struct FlowTraits<quantra::FlowInterest> {
  static const Flow enum_value = Flow_FlowInterest;
};

template<> struct FlowTraits<quantra::FlowPastInterest> {
  static const Flow enum_value = Flow_FlowPastInterest;
};

template<> struct FlowTraits<quantra::FlowNotional> {
  static const Flow enum_value = Flow_FlowNotional;
};

struct FlowUnion {
  Flow type;
  void *value;

  FlowUnion() : type(Flow_NONE), value(nullptr) {}
  FlowUnion(FlowUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(Flow_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  FlowUnion(const FlowUnion &);
  FlowUnion &operator=(const FlowUnion &u)
    { FlowUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  FlowUnion &operator=(FlowUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~FlowUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = FlowTraits<typename RT::TableType>::enum_value;
    if (type != Flow_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, Flow type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  quantra::FlowInterestT *AsFlowInterest() {
    return type == Flow_FlowInterest ?
      reinterpret_cast<quantra::FlowInterestT *>(value) : nullptr;
  }
  const quantra::FlowInterestT *AsFlowInterest() const {
    return type == Flow_FlowInterest ?
      reinterpret_cast<const quantra::FlowInterestT *>(value) : nullptr;
  }
  quantra::FlowPastInterestT *AsFlowPastInterest() {
    return type == Flow_FlowPastInterest ?
      reinterpret_cast<quantra::FlowPastInterestT *>(value) : nullptr;
  }
  const quantra::FlowPastInterestT *AsFlowPastInterest() const {
    return type == Flow_FlowPastInterest ?
      reinterpret_cast<const quantra::FlowPastInterestT *>(value) : nullptr;
  }
  quantra::FlowNotionalT *AsFlowNotional() {
    return type == Flow_FlowNotional ?
      reinterpret_cast<quantra::FlowNotionalT *>(value) : nullptr;
  }
  const quantra::FlowNotionalT *AsFlowNotional() const {
    return type == Flow_FlowNotional ?
      reinterpret_cast<const quantra::FlowNotionalT *>(value) : nullptr;
  }
};

bool VerifyFlow(flatbuffers::Verifier &verifier, const void *obj, Flow type);
bool VerifyFlowVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct YieldT : public flatbuffers::NativeTable {
  typedef Yield TableType;
  quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360;
  quantra::enums::Compounding compounding = quantra::enums::Compounding_Compounded;
  quantra::enums::Frequency frequency = quantra::enums::Frequency_Annual;
};

struct Yield FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef YieldT NativeTableType;
  typedef YieldBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DAY_COUNTER = 4,
    VT_COMPOUNDING = 6,
    VT_FREQUENCY = 8
  };
  quantra::enums::DayCounter day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_DAY_COUNTER, 0));
  }
  quantra::enums::Compounding compounding() const {
    return static_cast<quantra::enums::Compounding>(GetField<int8_t>(VT_COMPOUNDING, 0));
  }
  quantra::enums::Frequency frequency() const {
    return static_cast<quantra::enums::Frequency>(GetField<int8_t>(VT_FREQUENCY, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_DAY_COUNTER) &&
           VerifyField<int8_t>(verifier, VT_COMPOUNDING) &&
           VerifyField<int8_t>(verifier, VT_FREQUENCY) &&
           verifier.EndTable();
  }
  YieldT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(YieldT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Yield> Pack(flatbuffers::FlatBufferBuilder &_fbb, const YieldT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct YieldBuilder {
  typedef Yield Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_day_counter(quantra::enums::DayCounter day_counter) {
    fbb_.AddElement<int8_t>(Yield::VT_DAY_COUNTER, static_cast<int8_t>(day_counter), 0);
  }
  void add_compounding(quantra::enums::Compounding compounding) {
    fbb_.AddElement<int8_t>(Yield::VT_COMPOUNDING, static_cast<int8_t>(compounding), 0);
  }
  void add_frequency(quantra::enums::Frequency frequency) {
    fbb_.AddElement<int8_t>(Yield::VT_FREQUENCY, static_cast<int8_t>(frequency), 0);
  }
  explicit YieldBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Yield> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Yield>(end);
    return o;
  }
};

inline flatbuffers::Offset<Yield> CreateYield(
    flatbuffers::FlatBufferBuilder &_fbb,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360,
    quantra::enums::Compounding compounding = quantra::enums::Compounding_Compounded,
    quantra::enums::Frequency frequency = quantra::enums::Frequency_Annual) {
  YieldBuilder builder_(_fbb);
  builder_.add_frequency(frequency);
  builder_.add_compounding(compounding);
  builder_.add_day_counter(day_counter);
  return builder_.Finish();
}

flatbuffers::Offset<Yield> CreateYield(flatbuffers::FlatBufferBuilder &_fbb, const YieldT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PricingT : public flatbuffers::NativeTable {
  typedef Pricing TableType;
  std::string as_of_date{};
  std::string settlement_date{};
  std::vector<std::unique_ptr<quantra::TermStructureT>> curves{};
  bool bond_pricing_details = false;
  bool bond_pricing_flows = false;
  std::vector<std::unique_ptr<quantra::CouponPricerT>> coupon_pricers{};
};

struct Pricing FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PricingT NativeTableType;
  typedef PricingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AS_OF_DATE = 4,
    VT_SETTLEMENT_DATE = 6,
    VT_CURVES = 8,
    VT_BOND_PRICING_DETAILS = 10,
    VT_BOND_PRICING_FLOWS = 12,
    VT_COUPON_PRICERS = 14
  };
  const flatbuffers::String *as_of_date() const {
    return GetPointer<const flatbuffers::String *>(VT_AS_OF_DATE);
  }
  const flatbuffers::String *settlement_date() const {
    return GetPointer<const flatbuffers::String *>(VT_SETTLEMENT_DATE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<quantra::TermStructure>> *curves() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<quantra::TermStructure>> *>(VT_CURVES);
  }
  bool bond_pricing_details() const {
    return GetField<uint8_t>(VT_BOND_PRICING_DETAILS, 0) != 0;
  }
  bool bond_pricing_flows() const {
    return GetField<uint8_t>(VT_BOND_PRICING_FLOWS, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<quantra::CouponPricer>> *coupon_pricers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<quantra::CouponPricer>> *>(VT_COUPON_PRICERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AS_OF_DATE) &&
           verifier.VerifyString(as_of_date()) &&
           VerifyOffset(verifier, VT_SETTLEMENT_DATE) &&
           verifier.VerifyString(settlement_date()) &&
           VerifyOffset(verifier, VT_CURVES) &&
           verifier.VerifyVector(curves()) &&
           verifier.VerifyVectorOfTables(curves()) &&
           VerifyField<uint8_t>(verifier, VT_BOND_PRICING_DETAILS) &&
           VerifyField<uint8_t>(verifier, VT_BOND_PRICING_FLOWS) &&
           VerifyOffset(verifier, VT_COUPON_PRICERS) &&
           verifier.VerifyVector(coupon_pricers()) &&
           verifier.VerifyVectorOfTables(coupon_pricers()) &&
           verifier.EndTable();
  }
  PricingT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PricingT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Pricing> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PricingT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PricingBuilder {
  typedef Pricing Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_as_of_date(flatbuffers::Offset<flatbuffers::String> as_of_date) {
    fbb_.AddOffset(Pricing::VT_AS_OF_DATE, as_of_date);
  }
  void add_settlement_date(flatbuffers::Offset<flatbuffers::String> settlement_date) {
    fbb_.AddOffset(Pricing::VT_SETTLEMENT_DATE, settlement_date);
  }
  void add_curves(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<quantra::TermStructure>>> curves) {
    fbb_.AddOffset(Pricing::VT_CURVES, curves);
  }
  void add_bond_pricing_details(bool bond_pricing_details) {
    fbb_.AddElement<uint8_t>(Pricing::VT_BOND_PRICING_DETAILS, static_cast<uint8_t>(bond_pricing_details), 0);
  }
  void add_bond_pricing_flows(bool bond_pricing_flows) {
    fbb_.AddElement<uint8_t>(Pricing::VT_BOND_PRICING_FLOWS, static_cast<uint8_t>(bond_pricing_flows), 0);
  }
  void add_coupon_pricers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<quantra::CouponPricer>>> coupon_pricers) {
    fbb_.AddOffset(Pricing::VT_COUPON_PRICERS, coupon_pricers);
  }
  explicit PricingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Pricing> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pricing>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pricing> CreatePricing(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> as_of_date = 0,
    flatbuffers::Offset<flatbuffers::String> settlement_date = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<quantra::TermStructure>>> curves = 0,
    bool bond_pricing_details = false,
    bool bond_pricing_flows = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<quantra::CouponPricer>>> coupon_pricers = 0) {
  PricingBuilder builder_(_fbb);
  builder_.add_coupon_pricers(coupon_pricers);
  builder_.add_curves(curves);
  builder_.add_settlement_date(settlement_date);
  builder_.add_as_of_date(as_of_date);
  builder_.add_bond_pricing_flows(bond_pricing_flows);
  builder_.add_bond_pricing_details(bond_pricing_details);
  return builder_.Finish();
}

inline flatbuffers::Offset<Pricing> CreatePricingDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *as_of_date = nullptr,
    const char *settlement_date = nullptr,
    const std::vector<flatbuffers::Offset<quantra::TermStructure>> *curves = nullptr,
    bool bond_pricing_details = false,
    bool bond_pricing_flows = false,
    const std::vector<flatbuffers::Offset<quantra::CouponPricer>> *coupon_pricers = nullptr) {
  auto as_of_date__ = as_of_date ? _fbb.CreateString(as_of_date) : 0;
  auto settlement_date__ = settlement_date ? _fbb.CreateString(settlement_date) : 0;
  auto curves__ = curves ? _fbb.CreateVector<flatbuffers::Offset<quantra::TermStructure>>(*curves) : 0;
  auto coupon_pricers__ = coupon_pricers ? _fbb.CreateVector<flatbuffers::Offset<quantra::CouponPricer>>(*coupon_pricers) : 0;
  return quantra::CreatePricing(
      _fbb,
      as_of_date__,
      settlement_date__,
      curves__,
      bond_pricing_details,
      bond_pricing_flows,
      coupon_pricers__);
}

flatbuffers::Offset<Pricing> CreatePricing(flatbuffers::FlatBufferBuilder &_fbb, const PricingT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ErrorT : public flatbuffers::NativeTable {
  typedef Error TableType;
  std::string error_message{};
};

struct Error FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ErrorT NativeTableType;
  typedef ErrorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_MESSAGE = 4
  };
  const flatbuffers::String *error_message() const {
    return GetPointer<const flatbuffers::String *>(VT_ERROR_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ERROR_MESSAGE) &&
           verifier.VerifyString(error_message()) &&
           verifier.EndTable();
  }
  ErrorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ErrorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Error> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ErrorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ErrorBuilder {
  typedef Error Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_message(flatbuffers::Offset<flatbuffers::String> error_message) {
    fbb_.AddOffset(Error::VT_ERROR_MESSAGE, error_message);
  }
  explicit ErrorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Error> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Error>(end);
    return o;
  }
};

inline flatbuffers::Offset<Error> CreateError(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> error_message = 0) {
  ErrorBuilder builder_(_fbb);
  builder_.add_error_message(error_message);
  return builder_.Finish();
}

inline flatbuffers::Offset<Error> CreateErrorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *error_message = nullptr) {
  auto error_message__ = error_message ? _fbb.CreateString(error_message) : 0;
  return quantra::CreateError(
      _fbb,
      error_message__);
}

flatbuffers::Offset<Error> CreateError(flatbuffers::FlatBufferBuilder &_fbb, const ErrorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FlowInterestT : public flatbuffers::NativeTable {
  typedef FlowInterest TableType;
  double amount = 0.0;
  std::string fixing_date{};
  std::string accrual_start_date{};
  std::string accrual_end_date{};
  float discount = 0.0f;
  float rate = 0.0f;
  float price = 0.0f;
};

struct FlowInterest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FlowInterestT NativeTableType;
  typedef FlowInterestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AMOUNT = 4,
    VT_FIXING_DATE = 6,
    VT_ACCRUAL_START_DATE = 8,
    VT_ACCRUAL_END_DATE = 10,
    VT_DISCOUNT = 12,
    VT_RATE = 14,
    VT_PRICE = 16
  };
  double amount() const {
    return GetField<double>(VT_AMOUNT, 0.0);
  }
  const flatbuffers::String *fixing_date() const {
    return GetPointer<const flatbuffers::String *>(VT_FIXING_DATE);
  }
  const flatbuffers::String *accrual_start_date() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCRUAL_START_DATE);
  }
  const flatbuffers::String *accrual_end_date() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCRUAL_END_DATE);
  }
  float discount() const {
    return GetField<float>(VT_DISCOUNT, 0.0f);
  }
  float rate() const {
    return GetField<float>(VT_RATE, 0.0f);
  }
  float price() const {
    return GetField<float>(VT_PRICE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_AMOUNT) &&
           VerifyOffset(verifier, VT_FIXING_DATE) &&
           verifier.VerifyString(fixing_date()) &&
           VerifyOffset(verifier, VT_ACCRUAL_START_DATE) &&
           verifier.VerifyString(accrual_start_date()) &&
           VerifyOffset(verifier, VT_ACCRUAL_END_DATE) &&
           verifier.VerifyString(accrual_end_date()) &&
           VerifyField<float>(verifier, VT_DISCOUNT) &&
           VerifyField<float>(verifier, VT_RATE) &&
           VerifyField<float>(verifier, VT_PRICE) &&
           verifier.EndTable();
  }
  FlowInterestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FlowInterestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FlowInterest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlowInterestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FlowInterestBuilder {
  typedef FlowInterest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_amount(double amount) {
    fbb_.AddElement<double>(FlowInterest::VT_AMOUNT, amount, 0.0);
  }
  void add_fixing_date(flatbuffers::Offset<flatbuffers::String> fixing_date) {
    fbb_.AddOffset(FlowInterest::VT_FIXING_DATE, fixing_date);
  }
  void add_accrual_start_date(flatbuffers::Offset<flatbuffers::String> accrual_start_date) {
    fbb_.AddOffset(FlowInterest::VT_ACCRUAL_START_DATE, accrual_start_date);
  }
  void add_accrual_end_date(flatbuffers::Offset<flatbuffers::String> accrual_end_date) {
    fbb_.AddOffset(FlowInterest::VT_ACCRUAL_END_DATE, accrual_end_date);
  }
  void add_discount(float discount) {
    fbb_.AddElement<float>(FlowInterest::VT_DISCOUNT, discount, 0.0f);
  }
  void add_rate(float rate) {
    fbb_.AddElement<float>(FlowInterest::VT_RATE, rate, 0.0f);
  }
  void add_price(float price) {
    fbb_.AddElement<float>(FlowInterest::VT_PRICE, price, 0.0f);
  }
  explicit FlowInterestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FlowInterest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FlowInterest>(end);
    return o;
  }
};

inline flatbuffers::Offset<FlowInterest> CreateFlowInterest(
    flatbuffers::FlatBufferBuilder &_fbb,
    double amount = 0.0,
    flatbuffers::Offset<flatbuffers::String> fixing_date = 0,
    flatbuffers::Offset<flatbuffers::String> accrual_start_date = 0,
    flatbuffers::Offset<flatbuffers::String> accrual_end_date = 0,
    float discount = 0.0f,
    float rate = 0.0f,
    float price = 0.0f) {
  FlowInterestBuilder builder_(_fbb);
  builder_.add_amount(amount);
  builder_.add_price(price);
  builder_.add_rate(rate);
  builder_.add_discount(discount);
  builder_.add_accrual_end_date(accrual_end_date);
  builder_.add_accrual_start_date(accrual_start_date);
  builder_.add_fixing_date(fixing_date);
  return builder_.Finish();
}

inline flatbuffers::Offset<FlowInterest> CreateFlowInterestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double amount = 0.0,
    const char *fixing_date = nullptr,
    const char *accrual_start_date = nullptr,
    const char *accrual_end_date = nullptr,
    float discount = 0.0f,
    float rate = 0.0f,
    float price = 0.0f) {
  auto fixing_date__ = fixing_date ? _fbb.CreateString(fixing_date) : 0;
  auto accrual_start_date__ = accrual_start_date ? _fbb.CreateString(accrual_start_date) : 0;
  auto accrual_end_date__ = accrual_end_date ? _fbb.CreateString(accrual_end_date) : 0;
  return quantra::CreateFlowInterest(
      _fbb,
      amount,
      fixing_date__,
      accrual_start_date__,
      accrual_end_date__,
      discount,
      rate,
      price);
}

flatbuffers::Offset<FlowInterest> CreateFlowInterest(flatbuffers::FlatBufferBuilder &_fbb, const FlowInterestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FlowInterestFloatT : public flatbuffers::NativeTable {
  typedef FlowInterestFloat TableType;
  double amount = 0.0;
  std::string fixing_date{};
  std::string accrual_start_date{};
  std::string accrual_end_date{};
  float discount = 0.0f;
  float rate = 0.0f;
  float price = 0.0f;
};

struct FlowInterestFloat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FlowInterestFloatT NativeTableType;
  typedef FlowInterestFloatBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AMOUNT = 4,
    VT_FIXING_DATE = 6,
    VT_ACCRUAL_START_DATE = 8,
    VT_ACCRUAL_END_DATE = 10,
    VT_DISCOUNT = 12,
    VT_RATE = 14,
    VT_PRICE = 16
  };
  double amount() const {
    return GetField<double>(VT_AMOUNT, 0.0);
  }
  const flatbuffers::String *fixing_date() const {
    return GetPointer<const flatbuffers::String *>(VT_FIXING_DATE);
  }
  const flatbuffers::String *accrual_start_date() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCRUAL_START_DATE);
  }
  const flatbuffers::String *accrual_end_date() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCRUAL_END_DATE);
  }
  float discount() const {
    return GetField<float>(VT_DISCOUNT, 0.0f);
  }
  float rate() const {
    return GetField<float>(VT_RATE, 0.0f);
  }
  float price() const {
    return GetField<float>(VT_PRICE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_AMOUNT) &&
           VerifyOffset(verifier, VT_FIXING_DATE) &&
           verifier.VerifyString(fixing_date()) &&
           VerifyOffset(verifier, VT_ACCRUAL_START_DATE) &&
           verifier.VerifyString(accrual_start_date()) &&
           VerifyOffset(verifier, VT_ACCRUAL_END_DATE) &&
           verifier.VerifyString(accrual_end_date()) &&
           VerifyField<float>(verifier, VT_DISCOUNT) &&
           VerifyField<float>(verifier, VT_RATE) &&
           VerifyField<float>(verifier, VT_PRICE) &&
           verifier.EndTable();
  }
  FlowInterestFloatT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FlowInterestFloatT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FlowInterestFloat> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlowInterestFloatT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FlowInterestFloatBuilder {
  typedef FlowInterestFloat Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_amount(double amount) {
    fbb_.AddElement<double>(FlowInterestFloat::VT_AMOUNT, amount, 0.0);
  }
  void add_fixing_date(flatbuffers::Offset<flatbuffers::String> fixing_date) {
    fbb_.AddOffset(FlowInterestFloat::VT_FIXING_DATE, fixing_date);
  }
  void add_accrual_start_date(flatbuffers::Offset<flatbuffers::String> accrual_start_date) {
    fbb_.AddOffset(FlowInterestFloat::VT_ACCRUAL_START_DATE, accrual_start_date);
  }
  void add_accrual_end_date(flatbuffers::Offset<flatbuffers::String> accrual_end_date) {
    fbb_.AddOffset(FlowInterestFloat::VT_ACCRUAL_END_DATE, accrual_end_date);
  }
  void add_discount(float discount) {
    fbb_.AddElement<float>(FlowInterestFloat::VT_DISCOUNT, discount, 0.0f);
  }
  void add_rate(float rate) {
    fbb_.AddElement<float>(FlowInterestFloat::VT_RATE, rate, 0.0f);
  }
  void add_price(float price) {
    fbb_.AddElement<float>(FlowInterestFloat::VT_PRICE, price, 0.0f);
  }
  explicit FlowInterestFloatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FlowInterestFloat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FlowInterestFloat>(end);
    return o;
  }
};

inline flatbuffers::Offset<FlowInterestFloat> CreateFlowInterestFloat(
    flatbuffers::FlatBufferBuilder &_fbb,
    double amount = 0.0,
    flatbuffers::Offset<flatbuffers::String> fixing_date = 0,
    flatbuffers::Offset<flatbuffers::String> accrual_start_date = 0,
    flatbuffers::Offset<flatbuffers::String> accrual_end_date = 0,
    float discount = 0.0f,
    float rate = 0.0f,
    float price = 0.0f) {
  FlowInterestFloatBuilder builder_(_fbb);
  builder_.add_amount(amount);
  builder_.add_price(price);
  builder_.add_rate(rate);
  builder_.add_discount(discount);
  builder_.add_accrual_end_date(accrual_end_date);
  builder_.add_accrual_start_date(accrual_start_date);
  builder_.add_fixing_date(fixing_date);
  return builder_.Finish();
}

inline flatbuffers::Offset<FlowInterestFloat> CreateFlowInterestFloatDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double amount = 0.0,
    const char *fixing_date = nullptr,
    const char *accrual_start_date = nullptr,
    const char *accrual_end_date = nullptr,
    float discount = 0.0f,
    float rate = 0.0f,
    float price = 0.0f) {
  auto fixing_date__ = fixing_date ? _fbb.CreateString(fixing_date) : 0;
  auto accrual_start_date__ = accrual_start_date ? _fbb.CreateString(accrual_start_date) : 0;
  auto accrual_end_date__ = accrual_end_date ? _fbb.CreateString(accrual_end_date) : 0;
  return quantra::CreateFlowInterestFloat(
      _fbb,
      amount,
      fixing_date__,
      accrual_start_date__,
      accrual_end_date__,
      discount,
      rate,
      price);
}

flatbuffers::Offset<FlowInterestFloat> CreateFlowInterestFloat(flatbuffers::FlatBufferBuilder &_fbb, const FlowInterestFloatT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FlowPastInterestFloatT : public flatbuffers::NativeTable {
  typedef FlowPastInterestFloat TableType;
  double amount = 0.0;
  std::string fixing_date{};
  std::string accrual_start_date{};
  std::string accrual_end_date{};
  float rate = 0.0f;
};

struct FlowPastInterestFloat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FlowPastInterestFloatT NativeTableType;
  typedef FlowPastInterestFloatBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AMOUNT = 4,
    VT_FIXING_DATE = 6,
    VT_ACCRUAL_START_DATE = 8,
    VT_ACCRUAL_END_DATE = 10,
    VT_RATE = 12
  };
  double amount() const {
    return GetField<double>(VT_AMOUNT, 0.0);
  }
  const flatbuffers::String *fixing_date() const {
    return GetPointer<const flatbuffers::String *>(VT_FIXING_DATE);
  }
  const flatbuffers::String *accrual_start_date() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCRUAL_START_DATE);
  }
  const flatbuffers::String *accrual_end_date() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCRUAL_END_DATE);
  }
  float rate() const {
    return GetField<float>(VT_RATE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_AMOUNT) &&
           VerifyOffset(verifier, VT_FIXING_DATE) &&
           verifier.VerifyString(fixing_date()) &&
           VerifyOffset(verifier, VT_ACCRUAL_START_DATE) &&
           verifier.VerifyString(accrual_start_date()) &&
           VerifyOffset(verifier, VT_ACCRUAL_END_DATE) &&
           verifier.VerifyString(accrual_end_date()) &&
           VerifyField<float>(verifier, VT_RATE) &&
           verifier.EndTable();
  }
  FlowPastInterestFloatT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FlowPastInterestFloatT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FlowPastInterestFloat> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlowPastInterestFloatT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FlowPastInterestFloatBuilder {
  typedef FlowPastInterestFloat Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_amount(double amount) {
    fbb_.AddElement<double>(FlowPastInterestFloat::VT_AMOUNT, amount, 0.0);
  }
  void add_fixing_date(flatbuffers::Offset<flatbuffers::String> fixing_date) {
    fbb_.AddOffset(FlowPastInterestFloat::VT_FIXING_DATE, fixing_date);
  }
  void add_accrual_start_date(flatbuffers::Offset<flatbuffers::String> accrual_start_date) {
    fbb_.AddOffset(FlowPastInterestFloat::VT_ACCRUAL_START_DATE, accrual_start_date);
  }
  void add_accrual_end_date(flatbuffers::Offset<flatbuffers::String> accrual_end_date) {
    fbb_.AddOffset(FlowPastInterestFloat::VT_ACCRUAL_END_DATE, accrual_end_date);
  }
  void add_rate(float rate) {
    fbb_.AddElement<float>(FlowPastInterestFloat::VT_RATE, rate, 0.0f);
  }
  explicit FlowPastInterestFloatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FlowPastInterestFloat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FlowPastInterestFloat>(end);
    return o;
  }
};

inline flatbuffers::Offset<FlowPastInterestFloat> CreateFlowPastInterestFloat(
    flatbuffers::FlatBufferBuilder &_fbb,
    double amount = 0.0,
    flatbuffers::Offset<flatbuffers::String> fixing_date = 0,
    flatbuffers::Offset<flatbuffers::String> accrual_start_date = 0,
    flatbuffers::Offset<flatbuffers::String> accrual_end_date = 0,
    float rate = 0.0f) {
  FlowPastInterestFloatBuilder builder_(_fbb);
  builder_.add_amount(amount);
  builder_.add_rate(rate);
  builder_.add_accrual_end_date(accrual_end_date);
  builder_.add_accrual_start_date(accrual_start_date);
  builder_.add_fixing_date(fixing_date);
  return builder_.Finish();
}

inline flatbuffers::Offset<FlowPastInterestFloat> CreateFlowPastInterestFloatDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double amount = 0.0,
    const char *fixing_date = nullptr,
    const char *accrual_start_date = nullptr,
    const char *accrual_end_date = nullptr,
    float rate = 0.0f) {
  auto fixing_date__ = fixing_date ? _fbb.CreateString(fixing_date) : 0;
  auto accrual_start_date__ = accrual_start_date ? _fbb.CreateString(accrual_start_date) : 0;
  auto accrual_end_date__ = accrual_end_date ? _fbb.CreateString(accrual_end_date) : 0;
  return quantra::CreateFlowPastInterestFloat(
      _fbb,
      amount,
      fixing_date__,
      accrual_start_date__,
      accrual_end_date__,
      rate);
}

flatbuffers::Offset<FlowPastInterestFloat> CreateFlowPastInterestFloat(flatbuffers::FlatBufferBuilder &_fbb, const FlowPastInterestFloatT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FlowPastInterestT : public flatbuffers::NativeTable {
  typedef FlowPastInterest TableType;
  double amount = 0.0;
  std::string fixing_date{};
  std::string accrual_start_date{};
  std::string accrual_end_date{};
  float rate = 0.0f;
};

struct FlowPastInterest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FlowPastInterestT NativeTableType;
  typedef FlowPastInterestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AMOUNT = 4,
    VT_FIXING_DATE = 6,
    VT_ACCRUAL_START_DATE = 8,
    VT_ACCRUAL_END_DATE = 10,
    VT_RATE = 12
  };
  double amount() const {
    return GetField<double>(VT_AMOUNT, 0.0);
  }
  const flatbuffers::String *fixing_date() const {
    return GetPointer<const flatbuffers::String *>(VT_FIXING_DATE);
  }
  const flatbuffers::String *accrual_start_date() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCRUAL_START_DATE);
  }
  const flatbuffers::String *accrual_end_date() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCRUAL_END_DATE);
  }
  float rate() const {
    return GetField<float>(VT_RATE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_AMOUNT) &&
           VerifyOffset(verifier, VT_FIXING_DATE) &&
           verifier.VerifyString(fixing_date()) &&
           VerifyOffset(verifier, VT_ACCRUAL_START_DATE) &&
           verifier.VerifyString(accrual_start_date()) &&
           VerifyOffset(verifier, VT_ACCRUAL_END_DATE) &&
           verifier.VerifyString(accrual_end_date()) &&
           VerifyField<float>(verifier, VT_RATE) &&
           verifier.EndTable();
  }
  FlowPastInterestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FlowPastInterestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FlowPastInterest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlowPastInterestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FlowPastInterestBuilder {
  typedef FlowPastInterest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_amount(double amount) {
    fbb_.AddElement<double>(FlowPastInterest::VT_AMOUNT, amount, 0.0);
  }
  void add_fixing_date(flatbuffers::Offset<flatbuffers::String> fixing_date) {
    fbb_.AddOffset(FlowPastInterest::VT_FIXING_DATE, fixing_date);
  }
  void add_accrual_start_date(flatbuffers::Offset<flatbuffers::String> accrual_start_date) {
    fbb_.AddOffset(FlowPastInterest::VT_ACCRUAL_START_DATE, accrual_start_date);
  }
  void add_accrual_end_date(flatbuffers::Offset<flatbuffers::String> accrual_end_date) {
    fbb_.AddOffset(FlowPastInterest::VT_ACCRUAL_END_DATE, accrual_end_date);
  }
  void add_rate(float rate) {
    fbb_.AddElement<float>(FlowPastInterest::VT_RATE, rate, 0.0f);
  }
  explicit FlowPastInterestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FlowPastInterest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FlowPastInterest>(end);
    return o;
  }
};

inline flatbuffers::Offset<FlowPastInterest> CreateFlowPastInterest(
    flatbuffers::FlatBufferBuilder &_fbb,
    double amount = 0.0,
    flatbuffers::Offset<flatbuffers::String> fixing_date = 0,
    flatbuffers::Offset<flatbuffers::String> accrual_start_date = 0,
    flatbuffers::Offset<flatbuffers::String> accrual_end_date = 0,
    float rate = 0.0f) {
  FlowPastInterestBuilder builder_(_fbb);
  builder_.add_amount(amount);
  builder_.add_rate(rate);
  builder_.add_accrual_end_date(accrual_end_date);
  builder_.add_accrual_start_date(accrual_start_date);
  builder_.add_fixing_date(fixing_date);
  return builder_.Finish();
}

inline flatbuffers::Offset<FlowPastInterest> CreateFlowPastInterestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double amount = 0.0,
    const char *fixing_date = nullptr,
    const char *accrual_start_date = nullptr,
    const char *accrual_end_date = nullptr,
    float rate = 0.0f) {
  auto fixing_date__ = fixing_date ? _fbb.CreateString(fixing_date) : 0;
  auto accrual_start_date__ = accrual_start_date ? _fbb.CreateString(accrual_start_date) : 0;
  auto accrual_end_date__ = accrual_end_date ? _fbb.CreateString(accrual_end_date) : 0;
  return quantra::CreateFlowPastInterest(
      _fbb,
      amount,
      fixing_date__,
      accrual_start_date__,
      accrual_end_date__,
      rate);
}

flatbuffers::Offset<FlowPastInterest> CreateFlowPastInterest(flatbuffers::FlatBufferBuilder &_fbb, const FlowPastInterestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FlowNotionalT : public flatbuffers::NativeTable {
  typedef FlowNotional TableType;
  std::string date{};
  double amount = 0.0;
  float discount = 0.0f;
  float price = 0.0f;
};

struct FlowNotional FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FlowNotionalT NativeTableType;
  typedef FlowNotionalBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATE = 4,
    VT_AMOUNT = 6,
    VT_DISCOUNT = 8,
    VT_PRICE = 10
  };
  const flatbuffers::String *date() const {
    return GetPointer<const flatbuffers::String *>(VT_DATE);
  }
  double amount() const {
    return GetField<double>(VT_AMOUNT, 0.0);
  }
  float discount() const {
    return GetField<float>(VT_DISCOUNT, 0.0f);
  }
  float price() const {
    return GetField<float>(VT_PRICE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATE) &&
           verifier.VerifyString(date()) &&
           VerifyField<double>(verifier, VT_AMOUNT) &&
           VerifyField<float>(verifier, VT_DISCOUNT) &&
           VerifyField<float>(verifier, VT_PRICE) &&
           verifier.EndTable();
  }
  FlowNotionalT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FlowNotionalT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FlowNotional> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlowNotionalT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FlowNotionalBuilder {
  typedef FlowNotional Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_date(flatbuffers::Offset<flatbuffers::String> date) {
    fbb_.AddOffset(FlowNotional::VT_DATE, date);
  }
  void add_amount(double amount) {
    fbb_.AddElement<double>(FlowNotional::VT_AMOUNT, amount, 0.0);
  }
  void add_discount(float discount) {
    fbb_.AddElement<float>(FlowNotional::VT_DISCOUNT, discount, 0.0f);
  }
  void add_price(float price) {
    fbb_.AddElement<float>(FlowNotional::VT_PRICE, price, 0.0f);
  }
  explicit FlowNotionalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FlowNotional> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FlowNotional>(end);
    return o;
  }
};

inline flatbuffers::Offset<FlowNotional> CreateFlowNotional(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> date = 0,
    double amount = 0.0,
    float discount = 0.0f,
    float price = 0.0f) {
  FlowNotionalBuilder builder_(_fbb);
  builder_.add_amount(amount);
  builder_.add_price(price);
  builder_.add_discount(discount);
  builder_.add_date(date);
  return builder_.Finish();
}

inline flatbuffers::Offset<FlowNotional> CreateFlowNotionalDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *date = nullptr,
    double amount = 0.0,
    float discount = 0.0f,
    float price = 0.0f) {
  auto date__ = date ? _fbb.CreateString(date) : 0;
  return quantra::CreateFlowNotional(
      _fbb,
      date__,
      amount,
      discount,
      price);
}

flatbuffers::Offset<FlowNotional> CreateFlowNotional(flatbuffers::FlatBufferBuilder &_fbb, const FlowNotionalT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FlowsWrapperT : public flatbuffers::NativeTable {
  typedef FlowsWrapper TableType;
  quantra::FlowUnion flow{};
};

struct FlowsWrapper FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FlowsWrapperT NativeTableType;
  typedef FlowsWrapperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FLOW_TYPE = 4,
    VT_FLOW = 6
  };
  quantra::Flow flow_type() const {
    return static_cast<quantra::Flow>(GetField<uint8_t>(VT_FLOW_TYPE, 0));
  }
  const void *flow() const {
    return GetPointer<const void *>(VT_FLOW);
  }
  template<typename T> const T *flow_as() const;
  const quantra::FlowInterest *flow_as_FlowInterest() const {
    return flow_type() == quantra::Flow_FlowInterest ? static_cast<const quantra::FlowInterest *>(flow()) : nullptr;
  }
  const quantra::FlowPastInterest *flow_as_FlowPastInterest() const {
    return flow_type() == quantra::Flow_FlowPastInterest ? static_cast<const quantra::FlowPastInterest *>(flow()) : nullptr;
  }
  const quantra::FlowNotional *flow_as_FlowNotional() const {
    return flow_type() == quantra::Flow_FlowNotional ? static_cast<const quantra::FlowNotional *>(flow()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_FLOW_TYPE) &&
           VerifyOffset(verifier, VT_FLOW) &&
           VerifyFlow(verifier, flow(), flow_type()) &&
           verifier.EndTable();
  }
  FlowsWrapperT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FlowsWrapperT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FlowsWrapper> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlowsWrapperT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const quantra::FlowInterest *FlowsWrapper::flow_as<quantra::FlowInterest>() const {
  return flow_as_FlowInterest();
}

template<> inline const quantra::FlowPastInterest *FlowsWrapper::flow_as<quantra::FlowPastInterest>() const {
  return flow_as_FlowPastInterest();
}

template<> inline const quantra::FlowNotional *FlowsWrapper::flow_as<quantra::FlowNotional>() const {
  return flow_as_FlowNotional();
}

struct FlowsWrapperBuilder {
  typedef FlowsWrapper Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_flow_type(quantra::Flow flow_type) {
    fbb_.AddElement<uint8_t>(FlowsWrapper::VT_FLOW_TYPE, static_cast<uint8_t>(flow_type), 0);
  }
  void add_flow(flatbuffers::Offset<void> flow) {
    fbb_.AddOffset(FlowsWrapper::VT_FLOW, flow);
  }
  explicit FlowsWrapperBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FlowsWrapper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FlowsWrapper>(end);
    return o;
  }
};

inline flatbuffers::Offset<FlowsWrapper> CreateFlowsWrapper(
    flatbuffers::FlatBufferBuilder &_fbb,
    quantra::Flow flow_type = quantra::Flow_NONE,
    flatbuffers::Offset<void> flow = 0) {
  FlowsWrapperBuilder builder_(_fbb);
  builder_.add_flow(flow);
  builder_.add_flow_type(flow_type);
  return builder_.Finish();
}

flatbuffers::Offset<FlowsWrapper> CreateFlowsWrapper(flatbuffers::FlatBufferBuilder &_fbb, const FlowsWrapperT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline YieldT *Yield::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<YieldT>(new YieldT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Yield::UnPackTo(YieldT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = day_counter(); _o->day_counter = _e; }
  { auto _e = compounding(); _o->compounding = _e; }
  { auto _e = frequency(); _o->frequency = _e; }
}

inline flatbuffers::Offset<Yield> Yield::Pack(flatbuffers::FlatBufferBuilder &_fbb, const YieldT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateYield(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Yield> CreateYield(flatbuffers::FlatBufferBuilder &_fbb, const YieldT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const YieldT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _day_counter = _o->day_counter;
  auto _compounding = _o->compounding;
  auto _frequency = _o->frequency;
  return quantra::CreateYield(
      _fbb,
      _day_counter,
      _compounding,
      _frequency);
}

inline PricingT *Pricing::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PricingT>(new PricingT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Pricing::UnPackTo(PricingT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = as_of_date(); if (_e) _o->as_of_date = _e->str(); }
  { auto _e = settlement_date(); if (_e) _o->settlement_date = _e->str(); }
  { auto _e = curves(); if (_e) { _o->curves.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->curves[_i]) { _e->Get(_i)->UnPackTo(_o->curves[_i].get(), _resolver); } else { _o->curves[_i] = std::unique_ptr<quantra::TermStructureT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = bond_pricing_details(); _o->bond_pricing_details = _e; }
  { auto _e = bond_pricing_flows(); _o->bond_pricing_flows = _e; }
  { auto _e = coupon_pricers(); if (_e) { _o->coupon_pricers.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->coupon_pricers[_i]) { _e->Get(_i)->UnPackTo(_o->coupon_pricers[_i].get(), _resolver); } else { _o->coupon_pricers[_i] = std::unique_ptr<quantra::CouponPricerT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
}

inline flatbuffers::Offset<Pricing> Pricing::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PricingT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePricing(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Pricing> CreatePricing(flatbuffers::FlatBufferBuilder &_fbb, const PricingT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PricingT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _as_of_date = _o->as_of_date.empty() ? 0 : _fbb.CreateString(_o->as_of_date);
  auto _settlement_date = _o->settlement_date.empty() ? 0 : _fbb.CreateString(_o->settlement_date);
  auto _curves = _o->curves.size() ? _fbb.CreateVector<flatbuffers::Offset<quantra::TermStructure>> (_o->curves.size(), [](size_t i, _VectorArgs *__va) { return CreateTermStructure(*__va->__fbb, __va->__o->curves[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _bond_pricing_details = _o->bond_pricing_details;
  auto _bond_pricing_flows = _o->bond_pricing_flows;
  auto _coupon_pricers = _o->coupon_pricers.size() ? _fbb.CreateVector<flatbuffers::Offset<quantra::CouponPricer>> (_o->coupon_pricers.size(), [](size_t i, _VectorArgs *__va) { return CreateCouponPricer(*__va->__fbb, __va->__o->coupon_pricers[i].get(), __va->__rehasher); }, &_va ) : 0;
  return quantra::CreatePricing(
      _fbb,
      _as_of_date,
      _settlement_date,
      _curves,
      _bond_pricing_details,
      _bond_pricing_flows,
      _coupon_pricers);
}

inline ErrorT *Error::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ErrorT>(new ErrorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Error::UnPackTo(ErrorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error_message(); if (_e) _o->error_message = _e->str(); }
}

inline flatbuffers::Offset<Error> Error::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ErrorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateError(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Error> CreateError(flatbuffers::FlatBufferBuilder &_fbb, const ErrorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ErrorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _error_message = _o->error_message.empty() ? 0 : _fbb.CreateString(_o->error_message);
  return quantra::CreateError(
      _fbb,
      _error_message);
}

inline FlowInterestT *FlowInterest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FlowInterestT>(new FlowInterestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FlowInterest::UnPackTo(FlowInterestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = amount(); _o->amount = _e; }
  { auto _e = fixing_date(); if (_e) _o->fixing_date = _e->str(); }
  { auto _e = accrual_start_date(); if (_e) _o->accrual_start_date = _e->str(); }
  { auto _e = accrual_end_date(); if (_e) _o->accrual_end_date = _e->str(); }
  { auto _e = discount(); _o->discount = _e; }
  { auto _e = rate(); _o->rate = _e; }
  { auto _e = price(); _o->price = _e; }
}

inline flatbuffers::Offset<FlowInterest> FlowInterest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlowInterestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFlowInterest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FlowInterest> CreateFlowInterest(flatbuffers::FlatBufferBuilder &_fbb, const FlowInterestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FlowInterestT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _amount = _o->amount;
  auto _fixing_date = _o->fixing_date.empty() ? 0 : _fbb.CreateString(_o->fixing_date);
  auto _accrual_start_date = _o->accrual_start_date.empty() ? 0 : _fbb.CreateString(_o->accrual_start_date);
  auto _accrual_end_date = _o->accrual_end_date.empty() ? 0 : _fbb.CreateString(_o->accrual_end_date);
  auto _discount = _o->discount;
  auto _rate = _o->rate;
  auto _price = _o->price;
  return quantra::CreateFlowInterest(
      _fbb,
      _amount,
      _fixing_date,
      _accrual_start_date,
      _accrual_end_date,
      _discount,
      _rate,
      _price);
}

inline FlowInterestFloatT *FlowInterestFloat::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FlowInterestFloatT>(new FlowInterestFloatT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FlowInterestFloat::UnPackTo(FlowInterestFloatT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = amount(); _o->amount = _e; }
  { auto _e = fixing_date(); if (_e) _o->fixing_date = _e->str(); }
  { auto _e = accrual_start_date(); if (_e) _o->accrual_start_date = _e->str(); }
  { auto _e = accrual_end_date(); if (_e) _o->accrual_end_date = _e->str(); }
  { auto _e = discount(); _o->discount = _e; }
  { auto _e = rate(); _o->rate = _e; }
  { auto _e = price(); _o->price = _e; }
}

inline flatbuffers::Offset<FlowInterestFloat> FlowInterestFloat::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlowInterestFloatT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFlowInterestFloat(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FlowInterestFloat> CreateFlowInterestFloat(flatbuffers::FlatBufferBuilder &_fbb, const FlowInterestFloatT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FlowInterestFloatT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _amount = _o->amount;
  auto _fixing_date = _o->fixing_date.empty() ? 0 : _fbb.CreateString(_o->fixing_date);
  auto _accrual_start_date = _o->accrual_start_date.empty() ? 0 : _fbb.CreateString(_o->accrual_start_date);
  auto _accrual_end_date = _o->accrual_end_date.empty() ? 0 : _fbb.CreateString(_o->accrual_end_date);
  auto _discount = _o->discount;
  auto _rate = _o->rate;
  auto _price = _o->price;
  return quantra::CreateFlowInterestFloat(
      _fbb,
      _amount,
      _fixing_date,
      _accrual_start_date,
      _accrual_end_date,
      _discount,
      _rate,
      _price);
}

inline FlowPastInterestFloatT *FlowPastInterestFloat::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FlowPastInterestFloatT>(new FlowPastInterestFloatT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FlowPastInterestFloat::UnPackTo(FlowPastInterestFloatT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = amount(); _o->amount = _e; }
  { auto _e = fixing_date(); if (_e) _o->fixing_date = _e->str(); }
  { auto _e = accrual_start_date(); if (_e) _o->accrual_start_date = _e->str(); }
  { auto _e = accrual_end_date(); if (_e) _o->accrual_end_date = _e->str(); }
  { auto _e = rate(); _o->rate = _e; }
}

inline flatbuffers::Offset<FlowPastInterestFloat> FlowPastInterestFloat::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlowPastInterestFloatT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFlowPastInterestFloat(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FlowPastInterestFloat> CreateFlowPastInterestFloat(flatbuffers::FlatBufferBuilder &_fbb, const FlowPastInterestFloatT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FlowPastInterestFloatT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _amount = _o->amount;
  auto _fixing_date = _o->fixing_date.empty() ? 0 : _fbb.CreateString(_o->fixing_date);
  auto _accrual_start_date = _o->accrual_start_date.empty() ? 0 : _fbb.CreateString(_o->accrual_start_date);
  auto _accrual_end_date = _o->accrual_end_date.empty() ? 0 : _fbb.CreateString(_o->accrual_end_date);
  auto _rate = _o->rate;
  return quantra::CreateFlowPastInterestFloat(
      _fbb,
      _amount,
      _fixing_date,
      _accrual_start_date,
      _accrual_end_date,
      _rate);
}

inline FlowPastInterestT *FlowPastInterest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FlowPastInterestT>(new FlowPastInterestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FlowPastInterest::UnPackTo(FlowPastInterestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = amount(); _o->amount = _e; }
  { auto _e = fixing_date(); if (_e) _o->fixing_date = _e->str(); }
  { auto _e = accrual_start_date(); if (_e) _o->accrual_start_date = _e->str(); }
  { auto _e = accrual_end_date(); if (_e) _o->accrual_end_date = _e->str(); }
  { auto _e = rate(); _o->rate = _e; }
}

inline flatbuffers::Offset<FlowPastInterest> FlowPastInterest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlowPastInterestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFlowPastInterest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FlowPastInterest> CreateFlowPastInterest(flatbuffers::FlatBufferBuilder &_fbb, const FlowPastInterestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FlowPastInterestT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _amount = _o->amount;
  auto _fixing_date = _o->fixing_date.empty() ? 0 : _fbb.CreateString(_o->fixing_date);
  auto _accrual_start_date = _o->accrual_start_date.empty() ? 0 : _fbb.CreateString(_o->accrual_start_date);
  auto _accrual_end_date = _o->accrual_end_date.empty() ? 0 : _fbb.CreateString(_o->accrual_end_date);
  auto _rate = _o->rate;
  return quantra::CreateFlowPastInterest(
      _fbb,
      _amount,
      _fixing_date,
      _accrual_start_date,
      _accrual_end_date,
      _rate);
}

inline FlowNotionalT *FlowNotional::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FlowNotionalT>(new FlowNotionalT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FlowNotional::UnPackTo(FlowNotionalT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = date(); if (_e) _o->date = _e->str(); }
  { auto _e = amount(); _o->amount = _e; }
  { auto _e = discount(); _o->discount = _e; }
  { auto _e = price(); _o->price = _e; }
}

inline flatbuffers::Offset<FlowNotional> FlowNotional::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlowNotionalT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFlowNotional(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FlowNotional> CreateFlowNotional(flatbuffers::FlatBufferBuilder &_fbb, const FlowNotionalT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FlowNotionalT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _date = _o->date.empty() ? 0 : _fbb.CreateString(_o->date);
  auto _amount = _o->amount;
  auto _discount = _o->discount;
  auto _price = _o->price;
  return quantra::CreateFlowNotional(
      _fbb,
      _date,
      _amount,
      _discount,
      _price);
}

inline FlowsWrapperT *FlowsWrapper::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FlowsWrapperT>(new FlowsWrapperT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FlowsWrapper::UnPackTo(FlowsWrapperT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = flow_type(); _o->flow.type = _e; }
  { auto _e = flow(); if (_e) _o->flow.value = quantra::FlowUnion::UnPack(_e, flow_type(), _resolver); }
}

inline flatbuffers::Offset<FlowsWrapper> FlowsWrapper::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlowsWrapperT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFlowsWrapper(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FlowsWrapper> CreateFlowsWrapper(flatbuffers::FlatBufferBuilder &_fbb, const FlowsWrapperT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FlowsWrapperT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _flow_type = _o->flow.type;
  auto _flow = _o->flow.Pack(_fbb);
  return quantra::CreateFlowsWrapper(
      _fbb,
      _flow_type,
      _flow);
}

inline bool VerifyFlow(flatbuffers::Verifier &verifier, const void *obj, Flow type) {
  switch (type) {
    case Flow_NONE: {
      return true;
    }
    case Flow_FlowInterest: {
      auto ptr = reinterpret_cast<const quantra::FlowInterest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Flow_FlowPastInterest: {
      auto ptr = reinterpret_cast<const quantra::FlowPastInterest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Flow_FlowNotional: {
      auto ptr = reinterpret_cast<const quantra::FlowNotional *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyFlowVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyFlow(
        verifier,  values->Get(i), types->GetEnum<Flow>(i))) {
      return false;
    }
  }
  return true;
}

inline void *FlowUnion::UnPack(const void *obj, Flow type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case Flow_FlowInterest: {
      auto ptr = reinterpret_cast<const quantra::FlowInterest *>(obj);
      return ptr->UnPack(resolver);
    }
    case Flow_FlowPastInterest: {
      auto ptr = reinterpret_cast<const quantra::FlowPastInterest *>(obj);
      return ptr->UnPack(resolver);
    }
    case Flow_FlowNotional: {
      auto ptr = reinterpret_cast<const quantra::FlowNotional *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> FlowUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case Flow_FlowInterest: {
      auto ptr = reinterpret_cast<const quantra::FlowInterestT *>(value);
      return CreateFlowInterest(_fbb, ptr, _rehasher).Union();
    }
    case Flow_FlowPastInterest: {
      auto ptr = reinterpret_cast<const quantra::FlowPastInterestT *>(value);
      return CreateFlowPastInterest(_fbb, ptr, _rehasher).Union();
    }
    case Flow_FlowNotional: {
      auto ptr = reinterpret_cast<const quantra::FlowNotionalT *>(value);
      return CreateFlowNotional(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline FlowUnion::FlowUnion(const FlowUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case Flow_FlowInterest: {
      value = new quantra::FlowInterestT(*reinterpret_cast<quantra::FlowInterestT *>(u.value));
      break;
    }
    case Flow_FlowPastInterest: {
      value = new quantra::FlowPastInterestT(*reinterpret_cast<quantra::FlowPastInterestT *>(u.value));
      break;
    }
    case Flow_FlowNotional: {
      value = new quantra::FlowNotionalT(*reinterpret_cast<quantra::FlowNotionalT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void FlowUnion::Reset() {
  switch (type) {
    case Flow_FlowInterest: {
      auto ptr = reinterpret_cast<quantra::FlowInterestT *>(value);
      delete ptr;
      break;
    }
    case Flow_FlowPastInterest: {
      auto ptr = reinterpret_cast<quantra::FlowPastInterestT *>(value);
      delete ptr;
      break;
    }
    case Flow_FlowNotional: {
      auto ptr = reinterpret_cast<quantra::FlowNotionalT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = Flow_NONE;
}

}  // namespace quantra

#endif  // FLATBUFFERS_GENERATED_COMMON_QUANTRA_H_
